# ========== TU CONFIGURACIÓN ACTUAL (MANTENER TAL COMO ESTÁ) ==========
# Configuración principal de la aplicación
server.port=${PORT:8080}

# Configuración de base de datos con variables de entorno DE RENDER
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# Configuraciones de JPA
#spring.jpa.hibernate.ddl-auto=update
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.defer-datasource-initialization=true
spring.sql.init.mode=always
spring.jpa.show-sql=false

# Configuración de Vaadin
spring.mustache.check-template-location=false
vaadin.launch-browser=false
vaadin.allowed-packages=com.vaadin,org.vaadin,com.monitoring.server
vaadin.productionMode=${VAADIN_PRODUCTION_MODE:true}
vaadin.devmode.folder-access-mode=none
vaadin.frontend.timeout=300

# ===============================================
# AUTH0 CONFIGURATION - USANDO VARIABLES DE RENDER
# ===============================================
auth0.domain=${AUTH0_DOMAIN}
auth0.clientId=${AUTH0_CLIENT_ID}
auth0.clientSecret=${AUTH0_CLIENT_SECRET}
auth0.audience=${AUTH0_AUDIENCE}
app.baseUrl=${APP_BASE_URL}

# ===============================================
# SPRING SECURITY OAUTH2 CONFIGURATION
# ===============================================
spring.security.oauth2.client.registration.auth0.client-id=${auth0.clientId}
spring.security.oauth2.client.registration.auth0.client-secret=${auth0.clientSecret}
spring.security.oauth2.client.registration.auth0.scope=openid,profile,email
spring.security.oauth2.client.registration.auth0.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.auth0.redirect-uri=${app.baseUrl}/login/oauth2/code/auth0

spring.security.oauth2.client.provider.auth0.authorization-uri=https://${auth0.domain}/authorize
spring.security.oauth2.client.provider.auth0.token-uri=https://${auth0.domain}/oauth/token
spring.security.oauth2.client.provider.auth0.user-info-uri=https://${auth0.domain}/userinfo
spring.security.oauth2.client.provider.auth0.user-name-attribute=sub

# JWT Resource Server
spring.security.oauth2.resourceserver.jwt.issuer-uri=https://${auth0.domain}/
spring.security.oauth2.resourceserver.jwt.audiences=${auth0.audience}

# ===============================================
# LOGGING CONFIGURATION
# ===============================================
logging.level.org.atmosphere=warn
logging.level.com.monitoring=info
logging.level.org.springframework.security=${SECURITY_LOG_LEVEL:INFO}
logging.level.com.monitoring.server.security=${SECURITY_LOG_LEVEL:INFO}

# ===============================================
# ACTUATOR CONFIGURATION
# ===============================================
management.endpoints.web.exposure.include=health,metrics,info

# ===============================================
# SYSTEM MONITORING CONFIGURATION
# ===============================================
system.metric.collection.interval=${METRIC_COLLECTION_INTERVAL:10000}
system.process.collection.interval=${PROCESS_COLLECTION_INTERVAL:30000}
system.cpu.threshold=${CPU_THRESHOLD:80}
system.memory.threshold=${MEMORY_THRESHOLD:80}
system.disk.threshold=${DISK_THRESHOLD:90}

# ===============================================
# DEBUG LOGGING - TEMPORAL PARA DIAGNOSTICAR
# ===============================================
logging.level.com.monitoring.server.config=DEBUG
logging.level.org.springframework.security.oauth2=DEBUG
logging.level.org.springframework.web.servlet.DispatcherServlet=DEBUG
logging.level.org.springframework.security.web.authentication=DEBUG
logging.level.org.springframework.security.oauth2.client=DEBUG

# ========== AGREGAR ESTAS LÍNEAS AL FINAL (NUEVAS) ==========
# ===============================================
# CONFIGURACIONES ADICIONALES PARA TIEMPO REAL Y CRON
# ===============================================

# Configuración para tareas programadas y CRON jobs
spring.task.scheduling.pool.size=${SCHEDULING_POOL_SIZE:5}
spring.task.execution.pool.core-size=${EXECUTION_CORE_SIZE:3}
spring.task.execution.pool.max-size=${EXECUTION_MAX_SIZE:8}
spring.task.execution.pool.queue-capacity=${EXECUTION_QUEUE_CAPACITY:25}

# Configuración para WebSockets
spring.websocket.sockjs.transport.websocket.message-size-limit=${WS_MESSAGE_SIZE:8192}
spring.websocket.sockjs.transport.websocket.send-time-limit=${WS_SEND_TIME_LIMIT:20000}
spring.websocket.sockjs.transport.websocket.send-buffer-size-limit=${WS_BUFFER_SIZE:512000}

# ===============================================
# CONFIGURACIÓN AVANZADA DE MÉTRICAS (COMPATIBILIDAD CON EXISTENTE)
# ===============================================
server-monitor.metrics.collection-interval=${METRIC_COLLECTION_INTERVAL:5000}
server-monitor.metrics.cleanup-interval=${METRICS_CLEANUP_INTERVAL:3600000}
server-monitor.metrics.retention-days=${METRICS_RETENTION_DAYS:30}
server-monitor.metrics.max-points-per-chart=${METRICS_MAX_POINTS:20}

# Configuración para procesos (compatible con configuración existente)
server-monitor.processes.collection-interval=${PROCESS_COLLECTION_INTERVAL:10000}
server-monitor.processes.max-heavy-processes=${MAX_HEAVY_PROCESSES:10}

# ===============================================
# CONFIGURACIÓN PARA EXPORTACIÓN
# ===============================================
server-monitor.export.temp-directory=${EXPORT_TEMP_DIR:/tmp/server-monitor-exports}
server-monitor.export.max-file-size-mb=${EXPORT_MAX_FILE_SIZE:50}
server-monitor.export.enabled=${EXPORT_ENABLED:true}

# ===============================================
# LOGGING ESPECÍFICO PARA NUEVAS FUNCIONES
# ===============================================
logging.level.com.monitoring.server.service.impl.MetricCollectorService=${METRIC_COLLECTOR_LOG_LEVEL:INFO}
logging.level.org.springframework.scheduling=${SCHEDULING_LOG_LEVEL:INFO}
logging.level.org.springframework.websocket=${WEBSOCKET_LOG_LEVEL:INFO}

# ===============================================
# OPTIMIZACIONES DE RENDIMIENTO PARA PRODUCCIÓN
# ===============================================
spring.datasource.hikari.maximum-pool-size=${DB_MAX_POOL_SIZE:10}
spring.datasource.hikari.minimum-idle=${DB_MIN_IDLE:2}
spring.datasource.hikari.idle-timeout=${DB_IDLE_TIMEOUT:300000}
spring.datasource.hikari.connection-timeout=${DB_CONNECTION_TIMEOUT:20000}
spring.datasource.hikari.leak-detection-threshold=${DB_LEAK_DETECTION:60000}

# Cache configuration
spring.cache.type=${CACHE_TYPE:simple}

# ===============================================
# CONFIGURACIÓN CORS PARA WEBSOCKETS
# ===============================================
server-monitor.cors.allowed-origins=${ALLOWED_ORIGINS:${app.baseUrl},http://localhost:8080}
server-monitor.cors.allowed-methods=${ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
server-monitor.cors.allowed-headers=${ALLOWED_HEADERS:*}

# ===============================================
# CONFIGURACIÓN ESPECÍFICA PARA RENDER DEPLOY
# ===============================================
server.tomcat.threads.max=${TOMCAT_MAX_THREADS:50}
server.tomcat.threads.min-spare=${TOMCAT_MIN_THREADS:5}
server.tomcat.max-connections=${TOMCAT_MAX_CONNECTIONS:200}
server.tomcat.connection-timeout=${TOMCAT_CONNECTION_TIMEOUT:20000}
spring.transaction.default-timeout=${TRANSACTION_TIMEOUT:30}

# ===============================================
# CONFIGURACIÓN DE HEALTH CHECKS PARA RENDER
# ===============================================
management.endpoint.health.show-details=WHEN_AUTHORIZED
management.endpoint.metrics.enabled=${METRICS_ENDPOINT_ENABLED:true}
management.health.websocket.enabled=${HEALTH_WEBSOCKET_ENABLED:true}